# 規格驅動開發 (SDD)

## 權力倒轉

數十年來，程式碼一直是王道。規格為程式碼服務——它們是我們建構的鷹架，一旦「真正的」編碼工作開始就會被丟棄。我們撰寫 PRD 來指導開發，建立設計文件來告知實作，繪製圖表來視覺化架構。但這些總是從屬於程式碼本身。程式碼就是真理。其他一切充其量只是良好的意圖。程式碼是真相的來源，隨著它向前推進，規格很少能跟上步調。由於資產（程式碼）和實作是一體的，在不嘗試從程式碼建構的情況下，很難有平行實作。

規格驅動開發 (SDD) 顛覆了這種權力結構。規格不為程式碼服務——程式碼為規格服務。產品需求文件規格 (PRD) 不是實作的指南；它是產生實作的來源。技術計畫不是告知編碼的文件；它們是產生程式碼的精確定義。這不是我們建構軟體方式的漸進式改進。這是對驅動開發的根本重新思考。

規格與實作之間的差距自軟體開發誕生以來就一直困擾著它。我們試圖透過更好的文件、更詳細的需求、更嚴格的流程來彌合這個差距。這些方法失敗是因為它們接受差距是不可避免的。它們試圖縮小差距但從未消除它。SDD 透過讓規格或從規格誕生的具體實作計畫變得可執行來消除差距。當規格到實作計畫產生程式碼時，就沒有差距——只有轉換。

這種轉換現在成為可能，因為 AI 能夠理解和實作複雜的規格，並建立詳細的實作計畫。但沒有結構的原始 AI 生成會產生混亂。SDD 透過足夠精確、完整且明確的規格和後續實作計畫來提供這種結構，以產生可運作的系統。規格成為主要工件。程式碼成為它在特定語言和框架中的表達（作為實作計畫的實作）。

在這個新世界中，維護軟體意味著演進規格。開發團隊的意圖以自然語言（「**意圖驅動開發**」）、設計資產、核心原則和其他指導方針來表達。開發的 **通用語言** 移向更高層次，程式碼是最後一哩路的方法。

除錯意味著修復產生錯誤程式碼的規格和其實作計畫。重構意味著為了清晰度而重新結構化。整個開發工作流程圍繞規格作為中央真相來源重新組織，實作計畫和程式碼作為持續重新生成的輸出。因為我們是有創造力的存在，用新功能更新應用程式或建立新的平行實作，意味著重新審視規格並建立新的實作計畫。因此這個過程是 0 -> 1, (1', ..), 2, 3, N。

開發團隊專注於他們的創造力、實驗和批判性思考。

## SDD 工作流程實務

工作流程從一個想法開始——通常是模糊且不完整的。透過與 AI 的迭代對話，這個想法變成一個全面的 PRD。AI 提出澄清問題，識別邊緣情況，並協助定義精確的接受標準。在傳統開發中可能需要數天會議和文件工作的事情，在專注的規格工作中幾小時就能完成。這轉換了傳統的 SDLC——需求和設計變成持續的活動而非離散的階段。這支援 **團隊流程**，即團隊審查的規格被表達和版本化，在分支中建立並合併。

當產品經理更新接受標準時，實作計畫會自動標記受影響的技術決策。當架構師發現更好的模式時，PRD 會更新以反映新的可能性。

在整個規格流程中，研究代理程式收集關鍵背景資訊。它們調查函式庫相容性、效能基準和安全性影響。組織限制被自動發現和應用——你公司的資料庫標準、驗證需求和部署政策無縫整合到每個規格中。

從 PRD 開始，AI 產生將需求對應到技術決策的實作計畫。每個技術選擇都有記錄的理由。每個架構決策都可追溯到特定需求。在整個過程中，一致性驗證持續改善品質。AI 分析規格的模糊性、矛盾和差距——不是作為一次性的關卡，而是作為持續的精煉。

程式碼生成在規格和其實作計畫足夠穩定時就開始，但它們不必是「完整的」。早期生成可能是探索性的——測試規格在實務上是否合理。領域概念變成資料模型。使用者故事變成 API 端點。接受情境變成測試。這透過規格合併開發和測試——測試情境不是在程式碼之後撰寫，它們是產生實作和測試的規格的一部分。

回饋迴圈延伸到初始開發之外。生產指標和事件不只是觸發熱修復——它們為下一次重新生成更新規格。效能瓶頸變成新的非功能需求。安全性漏洞變成影響所有未來生成的限制。規格、實作和營運現實之間的這種迭代舞蹈是真正理解出現的地方，也是傳統 SDLC 轉換為持續演進的地方。

## 為什麼 SDD 現在很重要

三個趨勢讓 SDD 不僅成為可能，而且是必要的：

首先，AI 能力已達到自然語言規格可以可靠地產生可運作程式碼的門檻。這不是要取代開發者——而是透過自動化從規格到實作的機械性翻譯來放大他們的效能。它可以放大探索和創造力，可以輕鬆支援「重新開始」，支援加法減法和批判性思考。

其次，軟體複雜性持續指數級增長。現代系統整合數十個服務、框架和相依性。透過手動流程讓所有這些部分與原始意圖保持一致變得越來越困難。SDD 透過規格驅動生成提供系統性對齊。框架可能演進為提供 AI 優先支援，而非人類優先支援，或圍繞可重用元件進行架構。

第三，變化的步調加速。今天的需求變化比以往任何時候都更快速。轉向不再是例外——而是預期的。現代產品開發要求基於使用者回饋、市場條件和競爭壓力的快速迭代。傳統開發將這些變化視為干擾。每次轉向都需要手動將變化傳播到文件、設計和程式碼中。結果要麼是限制速度的緩慢、謹慎更新，要麼是累積技術債務的快速、魯莽變化。

SDD 可以支援假設/模擬實驗，「如果我們需要重新實作或變更應用程式以促進銷售更多 T 恤的商業需求，我們會如何實作和實驗？」。

SDD 將需求變化從障礙轉換為正常工作流程。當規格驅動實作時，轉向變成系統性重新生成而非手動重寫。變更 PRD 中的核心需求，受影響的實作計畫會自動更新。修改使用者故事，對應的 API 端點會重新生成。這不僅關於初始開發——而是關於透過不可避免的變化維持工程速度。

## 核心原則

**規格作為通用語言**：規格成為主要工件。程式碼成為它在特定語言和框架中的表達。維護軟體意味著演進規格。

**可執行規格**：規格必須足夠精確、完整且明確，以產生可運作的系統。這消除了意圖與實作之間的差距。

**持續精煉**：一致性驗證持續進行，而非作為一次性關卡。AI 分析規格的模糊性、矛盾和差距作為持續過程。

**研究驅動背景**：研究代理程式在整個規格過程中收集關鍵背景資訊，調查技術選項、效能影響和組織限制。

**雙向回饋**：生產現實告知規格演進。指標、事件和營運學習成為規格精煉的輸入。

**分支探索**：從同一規格產生多種實作方法，以探索不同的最佳化目標——效能、可維護性、使用者體驗、成本。

## 實作方法

今天，實踐 SDD 需要組合現有工具並在整個過程中保持紀律。該方法論可以透過以下方式實踐：

- 用於迭代規格開發的 AI 助理
- 用於收集技術背景的研究代理程式
- 用於將規格翻譯為實作的程式碼生成工具
- 適應規格優先工作流程的版本控制系統
- 透過 AI 分析規格文件的一致性檢查

關鍵是將規格視為真相來源，程式碼作為服務規格的生成輸出，而非相反。

## 使用 Claude 指令簡化 SDD

SDD 方法論透過兩個強大的 Claude 指令得到顯著增強，這些指令自動化規格和規劃工作流程：

### `new_feature` 指令

此指令將簡單的功能描述（使用者提示）轉換為完整、結構化的規格，並自動管理儲存庫：

1. **自動功能編號**：掃描現有規格以確定下一個功能編號（例如 001、002、003）
2. **分支建立**：從你的描述產生語義分支名稱並自動建立
3. **基於範本的生成**：複製並使用你的需求自訂功能規格範本
4. **目錄結構**：為所有相關文件建立適當的 `specs/[branch-name]/` 結構

### `generate_plan` 指令

一旦功能規格存在，此指令會建立全面的實作計畫：

1. **規格分析**：讀取並理解功能需求、使用者故事和接受標準
2. **憲法合規**：確保與專案憲法和架構原則一致
3. **技術翻譯**：將商業需求轉換為技術架構和實作細節
4. **詳細文件**：為資料模型、API 合約和測試情境產生支援文件
5. **手動測試計畫**：為每個使用者故事建立逐步驗證程序

### 範例：建構聊天功能

以下是這些指令如何轉換傳統開發工作流程：

**傳統方法：**

```
1. 在文件中撰寫 PRD（2-3 小時）
2. 建立設計文件（2-3 小時）
3. 手動設定專案結構（30 分鐘）
4. 撰寫技術規格（3-4 小時）
5. 建立測試計畫（2 小時）
總計：約 12 小時的文件工作
```

**使用指令的 SDD 方法：**

```bash
# 步驟 1：建立功能規格（5 分鐘）
/new_feature Real-time chat system with message history and user presence

# 這會自動：
# - 建立分支 "003-chat-system"
# - 產生 specs/003-chat-system/feature-spec.md
# - 用結構化需求填充它

# 步驟 2：產生實作計畫（10 分鐘）
/generate_plan WebSocket for real-time messaging, PostgreSQL for history, Redis for presence

# 這會自動建立：
# - specs/003-chat-system/implementation-plan.md
# - specs/003-chat-system/implementation-details/
#   - 00-research.md (WebSocket 函式庫比較)
#   - 02-data-model.md (訊息和使用者架構)
#   - 03-api-contracts.md (WebSocket 事件、REST 端點)
#   - 06-contract-tests.md (Message flow scenarios)
#   - 08-inter-library-tests.md (Database-WebSocket integration)
# - specs/003-chat-system/manual-testing.md
```

在 15 分鐘內，你擁有：

- 包含使用者故事和接受標準的完整功能規格
- 包含技術選擇和理由的詳細實作計畫
- 準備好進行程式碼生成的 API 合約和資料模型
- 自動化和手動測試的全面測試情境
- 在功能分支中適當版本化的所有文件

### 結構化自動化的力量

這些指令不僅節省時間——它們強制執行一致性和完整性：

1. **沒有遺忘的細節**：範本確保考慮每個方面，從非功能需求到錯誤處理
2. **可追溯的決策**：每個技術選擇都連結回特定需求
3. **活文件**：規格與程式碼保持同步，因為它們產生程式碼
4. **快速迭代**：在幾分鐘而非幾天內變更需求並重新生成計畫

這些指令透過將規格視為可執行工件而非靜態文件來體現 SDD 原則。它們將規格流程從必要之惡轉換為開發的驅動力。

### 範本驅動品質：結構如何約束 LLM 以獲得更好的結果

這些指令的真正力量不僅在於自動化，還在於範本如何引導 LLM 行為朝向更高品質的規格。範本作為複雜的提示，以有效的方式約束 LLM 的輸出：

#### 1. **防止過早的實作細節**

功能規格範本明確指示：

```
- ✅ 專注於使用者需要什麼以及為什麼
- ❌ 避免如何實作（無技術堆疊、API、程式碼結構）
```

這個限制強制 LLM 維持適當的抽象層級。當 LLM 可能自然地跳到「使用 React 和 Redux 實作」時，範本讓它專注於「使用者需要即時更新他們的資料」。這種分離確保規格即使在實作技術變更時也保持穩定。

#### 2. **強制明確的不確定性標記**

兩個範本都要求使用 `[NEEDS CLARIFICATION]` 標記：

```
從使用者提示建立此規格時：
1. **標記所有模糊之處**：使用 [NEEDS CLARIFICATION: 具體問題]
2. **不要猜測**：如果提示沒有指定某些內容，請標記它
```

這防止了 LLM 做出看似合理但可能不正確假設的常見行為。LLM 不會猜測「登入系統」使用電子郵件/密碼驗證，而必須將其標記為 `[NEEDS CLARIFICATION: 未指定驗證方法 - 電子郵件/密碼、SSO、OAuth？]`。

#### 3. **透過檢查清單進行結構化思考**

範本包含全面的檢查清單，作為規格的「單元測試」：

```
### 需求完整性
- [ ] 不再有 [NEEDS CLARIFICATION] 標記
- [ ] 需求可測試且明確
- [ ] 成功標準可衡量
```

這些檢查清單強制 LLM 系統性地自我審查其輸出，捕捉可能遺漏的差距。這就像為 LLM 提供品質保證框架。

#### 4. **透過閘門進行憲法合規**

實作計畫範本透過階段閘門強制執行架構原則：

```
### 階段 -1：實作前閘門
#### 簡潔性閘門（第七條）
- [ ] 使用 ≤3 個專案？
- [ ] 沒有未來防護？
#### 反抽象閘門（第八條）
- [ ] 直接使用框架？
- [ ] 單一模型表示？
```

這些閘門透過讓 LLM 明確證明任何複雜性的合理性來防止過度工程化。如果閘門失敗，LLM 必須在「複雜度追蹤」章節中記錄原因，為架構決策建立問責制。

#### 5. **階層式細節管理**

範本強制執行適當的資訊架構：

```
**重要**：此實作計畫應保持高層次且可讀。
任何程式碼範例、詳細演算法或廣泛的技術規格
都必須放置在適當的 `implementation-details/` 檔案中
```

這防止了規格變成不可讀程式碼堆積的常見問題。LLM 學會維持適當的細節層級，將複雜性提取到單獨的檔案中，同時保持主文件的可導覽性。

#### 6. **測試優先思維**

實作範本強制執行測試優先開發：

```
### 檔案建立順序
1. 建立包含 API 規格的 `contracts/`
2. 按順序建立測試檔案：合約 → 整合 → e2e → 單元
3. 建立原始檔案以使測試通過
```

這個順序限制確保 LLM 在實作之前思考可測試性和合約，導致更強健且可驗證的規格。

#### 7. **防止投機性功能**

範本明確阻止投機行為：

```
- [ ] 沒有投機性或「可能需要」的功能
- [ ] 所有階段都有清楚的前置條件和交付項目
```

這阻止 LLM 新增使實作複雜化的「最好有」功能。每個功能都必須追溯到具有清楚接受標準的具體使用者故事。

### 複合效應

這些限制共同作用產生以下規格：

- **完整**：檢查清單確保沒有遺忘任何事項
- **明確**：強制澄清標記突出不確定性
- **可測試**：測試優先思維融入流程
- **可維護**：適當的抽象層級和資訊階層
- **可實作**：具有具體交付項目的清楚階段

範本將 LLM 從創意寫作者轉換為有紀律的規格工程師，將其能力導向產生一致的高品質、可執行規格，真正驅動開發。

## 憲法基礎：強制執行架構紀律

SDD 的核心是憲法——一套不可變的原則，管理規格如何變成程式碼。憲法（`base/memory/constitution.md`）作為系統的架構 DNA，確保每個生成的實作都維持一致性、簡潔性和品質。

### 開發的九條條文

憲法定義了九條條文，塑造開發流程的每個方面：

#### 第一條：函式庫優先原則

每個功能都必須從獨立函式庫開始——沒有例外。這從一開始就強制模組化設計：

```
Specify 中的每個功能都必須以獨立函式庫的形式開始存在。
任何功能都不得直接在應用程式程式碼中實作，
必須先抽象為可重用的函式庫元件。
```

這個原則確保規格產生模組化、可重用的程式碼，而非單體應用程式。當 LLM 產生實作計畫時，它必須將功能結構化為具有清楚邊界和最小相依性的函式庫。

#### 第二條：CLI 介面要求

每個函式庫都必須透過命令列介面公開其功能：

```
所有 CLI 介面都必須：
- 接受文字作為輸入（透過 stdin、參數或檔案）
- 產生文字作為輸出（透過 stdout）
- 支援 JSON 格式進行結構化資料交換
```

這強制執行可觀測性和可測試性。LLM 不能將功能隱藏在不透明的類別中——一切都必須透過基於文字的介面可存取和可驗證。

#### 第三條：測試優先要求

最具變革性的條文——測試之前不寫程式碼：

```
這是不可協商的：所有實作都必須遵循嚴格的測試驅動開發。
在以下條件滿足之前，不得撰寫任何實作程式碼：
1. 撰寫單元測試
2. 測試經過驗證並獲得使用者批准
3. 確認測試失敗（紅色階段）
```

這完全顛覆了傳統的 AI 程式碼生成。LLM 不是生成程式碼並希望它能運作，而是必須首先生成定義行為的全面測試，獲得批准，然後才生成實作。

#### 第七條和第八條：簡潔性和反抽象

這兩條配對的條文對抗過度工程化：

```
第 7.3 節：最小專案結構
- 初始實作最多 3 個專案
- 額外專案需要記錄的合理性證明

第 8.1 節：框架信任
- 直接使用框架功能而非包裝它們
```

當 LLM 可能自然地建立複雜的抽象時，這些條文強制它證明每一層複雜性的合理性。實作計畫範本的「階段 -1 閘門」直接強制執行這些原則。

#### 第九條：整合優先測試

優先考慮真實世界測試而非孤立的單元測試：

```
測試必須使用真實環境：
- 偏好真實資料庫而非模擬
- 使用實際服務實例而非存根
- 實作前必須進行合約測試
```

這確保生成的程式碼在實務中運作，而不僅僅是理論上。

### 透過範本強制執行憲法

實作計畫範本透過具體檢查點將這些條文操作化：

```markdown
### 階段 -1：實作前閘門

#### 簡潔性閘門（第七條）

- [ ] 使用 ≤3 個專案？
- [ ] 沒有未來防護？

#### 反抽象閘門（第八條）

- [ ] 直接使用框架？
- [ ] 單一模型表示？

#### 整合優先閘門（第九條）

- [ ] 合約已定義？
- [ ] 合約測試已撰寫？
```

這些閘門作為架構原則的編譯時檢查。LLM 不能在不通過閘門或在「複雜度追蹤」章節中記錄合理例外的情況下繼續。

### 不可變原則的力量

憲法的力量在於其不可變性。雖然實作細節可以演進，但核心原則保持不變。這提供：

1. **跨時間一致性**：今天生成的程式碼遵循與明年生成的程式碼相同的原則
2. **跨 LLM 一致性**：不同的 AI 模型產生架構相容的程式碼
3. **架構完整性**：每個功能都強化而非破壞系統設計
4. **品質保證**：測試優先、函式庫優先和簡潔原則確保可維護的程式碼

### 憲法演進

雖然原則是不可變的，但它們的應用可以演進：

```
第 4.2 節：修正流程
對此憲法的修改需要：
- 明確記錄變更理由
- 專案維護者的審查和批准
- 向後相容性評估
```

這允許方法論在保持穩定性的同時學習和改進。憲法透過標註日期的修正案顯示其自身的演進，展示如何基於真實世界經驗精煉原則。

### 超越規則：開發哲學

憲法不僅僅是規則手冊——它是塑造 LLM 如何思考程式碼生成的哲學：

- **可觀測性勝過不透明性**：一切都必須透過 CLI 介面可檢查
- **簡潔性勝過聰明性**：從簡單開始，只有在證明必要時才增加複雜性
- **整合勝過孤立**：在真實環境中測試，而非人工環境
- **模組化勝過單體**：每個功能都是具有清楚邊界的函式庫

透過將這些原則嵌入規格和規劃流程中，SDD 確保生成的程式碼不僅功能正常——還可維護、可測試且架構健全。憲法將 AI 從程式碼生成器轉換為尊重並強化系統設計原則的架構夥伴。

## 轉換

這不是要取代開發者或自動化創造力。而是透過自動化機械性翻譯來放大人類能力。這是關於建立一個緊密的回饋迴圈，其中規格、研究和程式碼一起演進，每次迭代都帶來更深的理解和意圖與實作之間更好的對齊。

軟體開發需要更好的工具來維持意圖與實作之間的對齊。SDD 提供透過產生程式碼而非僅僅指導程式碼的可執行規格來實現這種對齊的方法論。
